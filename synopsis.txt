# Bulgogi Synopsis
# C v0.1.0

# NOTE: Largely inspired by git cli.

# Why C?
I care about really good technology. 

Leading all the way up to version InDev v0.8.0, C++ was promising largely thanks to its `std::unordered_map`s and other goodies.

The C++ community also had 'nice' libraries to offer, like `CLI11` for the arg parser and `yaml-cpp` for the yaml parsing.

But when a parsing a few lines of yaml and a small CLI set of 5 subcommands grew to generate a 6.65 MB binary, something didn't sit right.

Proof:
-rwxr-xr-x    1 alex  staff  6657264 24 Jan 17:41 bul

The same kind of bad feeling you get when you made too much cereal and had to throw some out. It feels wasteful.

With this project, there are no corporate deadlines. There are no developer qualms about writing low-level code.

Quite frankly, my annoyance with the C++ compile times alone brings me sufficient joy to want to spend 10x longer writing C code from scratch.

I don't just want a tool that does what it promotes - I want good technology. I want the best.

# DEPRECATED (not using C++)
## Why C++?
As far as bulgogi is concerned, what the project needs is a community; an ability to grow in features and be maintainable by many other people. Even if Rust is faster to implement features in (itâ€™s not) and more maintainable (probably is), having access to 1/20th of the developer pool at best and 1/100th of the developer-years of experience available significantly shrinks the pool of interested and capable contributors to the core codebase.

# Why CEX?
Because given enough time and developers, the gargantuan set of C++ features leads to mind-splintering code. Restricting that to "basically C" is the only sane approach.
# END DEPRECATED

# Initializes a new bulgogi project in the current dir
bulgogi init

# Empty projects do not contain anything.

# Alias: Bulgogi CLI tool should be aliased to `bul`.

# Adds a module to the bulgogi project
bulgogi module add module1
bulgogi module add --create telemetry

# Adds a module to a specific target 
# (Adds to the default target if not specified)
# (--create flag specifies that the module folder does not yet exist)
bulgogi module add module1 target1
bulgogi module add --create telemetry utils 

# Adds a new target to the project 
# (--library or --binary) specifies which type explicitly (default binary)
bulgogi target add target1 
bulgogi target add --library utils

# Build project
bulgogi build

# Clean project
# Specifically, removes all untracked project files and directories
bulgogi clean

# Removes module from the project
bulgogi rm module/

# Alternative ideas
# bulgogi module rm module1/
# bulgogi module rm --cached module1/
# (simply removes module from tracking but preserves files)

# Display project structure (tree)
bulgogi tree

# Sample output from bulgogi tree
# target1
#  |_ module1 (C++)
#  |_ module2 (C++)
# 
# target2
#  |_ module3 (Py3)
#  |_ target1 (C++)

# Smart functions (educated guesses)
bulgogi add module2   # Detects module, aliases to module add module2 
bulgogi rm telemetry  # Detects module, aliases to module rm module2 
bulgogi add source3.c # Source detected, creates a module for it and moves it 
bulgogi add source5.c module2 # Adds source to specific module 

###########################################################

# File: project.yaml
# Contains the project structure persistent state.
# Bulgogi primarily works by reading and updating this file.

# project.yaml
default:		# Target 
	module1*	# Dependency 1 (contains main)
	module2		# Dependency 2

target1:		# Target
	module3		# Dependency 1
	module4		# Dependency 2

target2:		# Target
	module3		# Dependency 1
	module5*	# Dependency 2 (contains main)
	target1		# Dependency 3 (implies target1 is a lib/shared lib)

**NOTE: A dependency can be a target OR a module. Targets used as dependencies imply lib.

# project directory
project/
	|- module1/
		|- inc/
			|- header1.h
			|- header2.h 
		|- src/
			|- source1.c 
			|- source2.c 
			|- inc/
				|- private1.h 
				|- private2.h 

/* Repeat the same for module 2 */

# CMake Targets
default:	# default.out			# What the user wants
	module1*	# default.out		# What bulgogi tells CMake
	module2		# libmodule2.a		# || || || || || || || ||

target1:	# libtarget1.a
	module3		# libmodule3.a
	module4		# libmodule4.a

target2:	# target2.out
	module3		# libmodule3.a
	module5*	# target2.out
	target1		# libtarget1.a (implies library)

# Exceptions
default:	# default.out
	target1*	# Shared object?
	module2

target1:	# target1.out
	module1*	# target1.out

# Bottom line: targets marked as executable dependencies are treated as
# normal target-libraries

# HashMaps
targets:
        default: 
                kind: Executable 
        target1:
                kind: Library 
        target2:
                kind: Executable 

modules:
        module1:
                kind: Executable
        module2:
                kind: Normal
        module3:
                kind: Normal 
        module4:
                kind: Normal
        module5:
                kind: Executable

deps:
        default:
                Module(module1)
                Module(module2)
        target1:
                Module(module3)
                Module(module4)
        target2:
                Module(module3)
                Module(module5)
                Target(target1)

/** Long-form droney bits **/
# The Re-Introduction of Proxy Libs 
# ---------------------------------
# Lo and behold it is revealed that the idea of removing proxy libs came back to bite.
#
# I'm grateful that it happened so early-on (pre-bootstrapping) since it's a pretty fund-
# -amental error. I'd like to elaborate on it.
#
# The premise of bulgogi target libraries was that they could be purely interfaces. Just 
# intermediaries to executables. You can group low-level atomic modules together and form 
# these larger executables at the top. 
#
# That's fine, until you realize that some modules depend on others. And the moment this 
# happens, the current version of bulgogi begins to treat that higher-level module as a 
# target lib. In other words, as just an interface.
#
# And interfaces don't have source code. They just have other libs linked to them. This 
# also means no headers. No headers, no includes, no shared APIs.
#
# The way to fix this is to give library targets the option to have source code. The  
# problem is finding in which file or directory they should live. The way that the 
# templates work at the moment is by globbing sources and headers in a module dir 
# to form one libmodule (or the executable component of an executable target). 
# 
# Without a so-called 'proxy module' as is handled by the executable targets, there 
# is a need to create random directories (or floating CMakeLists.txt) which just 
# server to orchestrate these higher-level libraries.
#
# So - the inference engine needs an upgrade. It needs to not only be able to pin down 
# which modules contain the executable component for executable targets, but they also 
# need to pin down which modules the target lib will 'reside' in.
#
# ALTERNATIVELY, you _do_ create those directories for targets. After all, it wouldn't 
# be so inappropriate since the user _did_ ask for those targets to exist in the 
# project.yaml. I think the thing I wouldn't accept would be something similar for the 
# executables (and now that I think about it, it would be an impossible task for the 
# executables since the main() directives need to be inserted as sources directly.
#
# I actually seem to be a bit stuck on this. It may be best to give it a break until things 
# clear up. I can't tell if this is a problem on the CMake side of things (make the templates 
# from scratch) or whether it is bulgogi purely. Leaning towards the bulgogi configuration.
#
# Ideallistically, for bulgogi's self build, I think the configuration I wish worked was:
#
# bulgogi:
# - client*
# - cmake
# - project
#
# And for that to work, I think it's CMake that may need to be changed. It almost feels to me 
# like `cmake` depending on `project` shouldn't matter when they're under the same umbrella...
#
# Anyway, like I said, I'll let this simmer.

# Re-thinking the executable marker (*)
# -------------------------------------
# I've really preferred the existing trend to always make sane assumptions 
# whenever possible so long as it simplifies and streamlines the UX.
#
# At first, the simplest thing was to say that every target is an executable 
# unless another target depends on it. This was really beautiful.
#
# The problem arose in the CMake configuration: executables needed sources that 
# contained a `main()` routine. This couldn't easily be worked around as 
# executable CMake targets are not very portable between other targets.
#
# The idea then came to have an executable marker (*) next to dependency names 
# of the modules that contained the `main()` routines. It would be unobtrusive 
# and signal that they are special (in fact they are).
#
# This would also be a nice visual check for conflicts: if there are more than 1 
# asterix-denoted entry in an executable target's list, there is a problem. There
# cannot be 2 `main()` routines.
# 
# So the latest issue is that requiring the executable marker has seemed both 
# redundant (target or library status can already be inferred) and a source of 
# occasional complication (which could escalate into needing intervention).
#
# For example, when the "default" target is created when the target field is 
# unspecified, this is nice is kick-starting a project with no modules. 
#
# But should the generated `project.yaml` _need_ to point out exactly which 
# module is executable? After all, there is only 1. Even if additional deps 
# are attached to the default target, they could all be library targets.
#
# Ambiguity error: instead of being required by default, the executability 
# market is *only* required when there is ambiguity. Ambiguity occurs when 
# an executable target has more than 1 module dependency.
#
# Advanced inference: it should also be possible to notice when the same 
# module is used in other targets as a non-executable. For example, if 
# any library targets include that suspected module, it could not be 
# executable. Therefore ambiguity is reduced.
#
# In fact, the only time there would be ambiguity is when more than one 
# executable share at least 2 modules that are not used anywhere else in 
# the project. This would seem like a special case.

# The need to re-use executable modules 
# -------------------------------------
# Suppose I wanted to release multiple variants of the same binary.
#
# I wouldn't have separate versions of the same `main()` beholden module.
#
# Consider the following targets:
#
# default:
# - module1*
# - module2
#
# default2:
# - module1*
# - module2
# - module7
# - flags:
#     - "-Duse_feature3"
#
# Ignore the non-existent `- flags:` entry for now. Notice how similar they are 
# but actually target different binaries? One has a pre-processor flag enabled 
# which inevitably actually requires different behaviour from the linker. Cool eh?

# The C Lag?
# ----------
# After the previously long-winded schpiel on C++ vs C, I've noticed that the lag that 
# I observed from running my C++ application (possibly in my head) seemed _just_ as bad 
# as that of my 'hello world' C program that I started just for sake of setting up the 
# Makefile.
#
# To be completely honest, I'm surprised - this is making me think that part of the irr-
# -ational basis for my grievance over C++ may go unchanged in C.
#
# If I don't get that superficial quick-execution from C (but the very cool/small binary
# fingerprint), will I really care or be much more proud? Will _others_ care? I just 
# can't answer that.
#
# I don't want to be so focused on the _what_ that I lose track of _why_. And I think 
# this is where _trying_ to start a revolution can be its downfall. 
#
# Personally, I have **no** opposition to substituting some modules of the program for C 
# in the future. I'm not writing an operating system or a bootloader, I can live with 
# dormant exceptions in the underbelly of the program. And if I so get interested in one 
# day replacing the whole thing in C, I can. But that slick superficial boost I was looking 
# for totally imploded in my hello-world test.
#
# In the end, data structures like unordered_maps are really handy representations of 
# things and they aren't at the root of my grievances (for example, I'd just as happily
# use an uglier / buggier C implementation I'd make myself of the equivalent of a string 
# lookup map specifically for the purpose of this...or would I?).
#
# Let's have some fun with this, either way.

# Taking a moment to reconsider C++
# ---------------------------------
# I've become quite cognizent of the bloat that has been introduced from the choice of 
# using C++. Not so much in the code that I've written myself for the project (although 
# still worth consideration) but moreso in the external libraries that were supposed to 
# introduced 'nice' functionality.
#
# On the one hand, 'nice' APIs with a lot of defaults built-in have a flatter learning 
# curve to them. Maybe it reduces the time until comfortable adjustment in half to 1/4 
# in more extreme cases. But once that hump is overcome, then what?
#
# I'm sitting on a +3 MB library dependency which just parses yaml. I'm sure it does a 
# good job at it - and certainly having the yaml.to<map> one-liner makes life awesome as 
# I get to move on with the map itself. But is that worth 3 MB?
#
# Further, on the topic of C++ exceptions, I got very interested in the idea of disabling 
# them. After all, any more than an abort() call when something goes wrong is not more or 
# less preventable than the fancy stack unwinding and often ambiguous exception messages 
# anyway.
#
# This proved to be a bit of a dead-end when the header-only library I was importing to 
# use for CLI parsing turned out to use the crap out of them. I _could_ rejig the library 
# not to use try/catch or throw statements, but then isn't that going against the work I
# originally wanted to prevent?
#
# This leads into the idea of building value into a project. What has made things like git 
# and linux so damn valuable wasn't so much the ends they achieved. Sure, your malloc()s 
# and your write()s are much needed, but plenty of Unix distributions and variants followed 
# this pattern (the so-called POSIX standard) and surely _achieved_ what they described.
#
# Same goes for other version trackers. Even if mercurial had 100% the same API as git 
# (which it seems to be pretty similar anyway), git would somehow come out on top.
#
# When I think about Minecraft, somehow a game with 100% the same mechanics and visuals,
# I still feel a bit off about using the non-OG version. As Minecraft is more than a game,
# it's a game-engine. 
#
# Git is more than just a version tracker, it's _part_ of the directory. And it would 
# only be able to do that if its footprint was small enough to be negligible.
#
# The bigger and hunkier a program is, the more setup and involvement it requires and 
# the easier it is the notice, the less seamless it becomes. A program can never 
# become essential if it constantly reminds the user and the system of its existence.
#
# I don't just want features - that's something C++ and even Python can give me just fine.
# I want to build the mother of all build-system projects. I need a program which takes 
# everything I know and puts it into one place so I can springboard off of that point 
# anytime I start a new project.
#
# And unfortunately I know better than to link 3 MB libraries to parse yaml.

# Gotta give up on proxy libraries 
# --------------------------------
# After many flip flops, I have realized that it will not be practical
# to use proxy submodules for Bulgogi/CMake libraries.
#
# The main reason for this being that, unlike executable proxies (which are
# required), proxy libraries are not indicated in the project config.
#
# Although it would not be impossible to implement a 'dibs' system on such 
# proxy lib submodules, this can allow for situations in which 2 'twin' target
# libraries are defined with the same module-dependencies. The orchestrator would
# need to account for these situations, which would be annoying and require more 
# back and forth with the user.
#
# The simplest solution here is to compile modules as standalone libraries and then 
# add each of the target-libraries to the CMake build as meta-libraries which simply 
# link globs of libmodules together.
#
# Executables then proxy themselves based on the (*) indicator. Library targets are 
# declared in the highest-level CMakelist.txt after all of the submodules are included.

# The HashMap Update: 0.5.0
# -------------------------
# This time we've realized that HashMaps are our friends. 
#
# The Project struct will now be a hasmap which can be crawled like a graph.
#
# Every target has a target ID, which is in fact its name. The key will be a String.
#
# Targets have lists of Dependencies, of which some may be modules (with module IDs) and others 
# may be targets (with Target IDs corresponding to an existing target in the HashMap).
#
# This way, without fighting the underlying data structures, the desired representation and functionality 
# may be implemented. This will also greatly ease conversion from the bulgogi Project to a CMakeProject.
#
# Dependencies must also be defined. The must, at the very least, define a source directory or another 
# target.

# I just remembered: executables are special 
# ------------------------------------------
# The whole need for "proxy" modules for targets stems from the special need for executable targets 
# to have the main() sources added directly to them.
#
# If a mechanism exists for executables to be created this way in the CMake translation, why wouldn't 
# libraries do this as well? Now I remember the line of thinking I was going on and why it's been so 
# damn hard to break from it.
#
# Still, for now, I think it would be best to let executables think they're special (and so treat them
# that way) and then continue with the direct interpretation for the libraries and the rest.
#
# So in other words: executables have proxy modules (which is what the * helps with anyway) and everything
# else is a library.

# New way of thinking: Bulgogi is a CMake orchestrator
# ----------------------------------------------------
# Rather than try and be clever by designating some module directories to be 'proxy' libraries 
# and executables, passing modules directly as libraries to CMake (even in cases when the library
# target and the module are indistinguishable) and leaving it to be CMake's problem (or the user's 
# desire), a level of simplicity and fine-grained control is simultaneously unlocked.
#
# I am seeing this as a bit of an A/B test, especially considering that I have flip-flopped between
# wanting to have proxy target modules and not. 
#
# On the positive end, proxy modules are a more natural/stylistic interpretation of the desired project
# layout. If a human were adapting the bulgogi project.yaml file into a CMake project, it would be 
# surprising to me if they would choose to create a library which only links to another lone library.
#
# On the flipside, if the bulgogi configuration _implies_ that a lone module is part of a lone library,
# why not accept this as the user's wish? This would be a much more direct interpretation of the desired
# project layout. This could be a very easy to produce a library file which I can send to my buddy just 
# on the side. 

# All modules are treated as libraries
# -----------------------------------
# Unless indicated by a * in the project config, all modules are treated like potential libraries.
# 
# This is helpful because it supports the existing CMake architecture that is being inherited and
# allows more than one target to link against the module.
#
# Additionally, when flagged as containing a main() routine with a *, executable targets can ensure
# the presence of a dedicated main() module. For simplicity, they can also be standalone executables
# in smaller/simpler projects

# Bulgogi targets are abstract groupings
# --------------------------------------
# As an orchestrator, bulgogi constructs and concepts are designed to faciliate
# build system management and the user development process.
#
# The high-level distinction between a target and a module is merely an abstraction
# which serves to distinguish products (executables) from intermediaries (libraries).
#
# This is not a conventional or 'good' way of thinking of binaries and libraries. But
# that isn't the point. Within a self-contained project, this is how things conceptually
# flow.

# Targets without an executable component
# ---------------------------------------
# A new thought: targets which do not have an executable component specified (module*)
# will be considered target libraries.
#
# This way, there are 3 kinds of CMake targets that bulgogi can generate:
# - Executable target (links against libraries + has executable component),
# - Library target (composed of modules but no executable component),
# - Library modules (smallest compilation unit recognized by bulgogi).

################## Cyclic Dependencies 
# A cyclic dependency check has been implemented for every conversion
# from a serde_yaml mapping into a Project struct.
#
# This is largely for A. safety (mistakes happen) and B. to prevent panics,
# runoffs and disasters down the road when those cyclic dependencies appear
# elsewhere (like in the CMake files which we are trying to keep the user
# out of in the first place).
#
# It currently works by iterating over each of the project targets and searching
# for target-type dependencies in other targets (or in itself for that matter).
# Further recursing is performed into each of the dependencies associated to the
# target-type dependencies until a match to the 'parent' target is found -- implying
# that by travelling laterally across the dependency tree we found our way back to the
# start.
#
# The user is notified and the program panics if this is encountered. No work should been
# done or attempted if the configuration suggests something impossible (or which could 
# easily be addressed using a common abstraction target which prevents the cycle).

################### Adding Modules
# As per the suggested synopsis, modules are to be added using the 
# $(bulgogi module add <name>) command.
#
# Unique to the init command, a default project and project directory must be spawned.
# Internally this is easy since the project struct just needs to be initialized to its 
# default value. 
#
# Ideas to spawn module directories:
# 1. Provide a .spawn() method for the project 
# 	- This would ensure that all module folders exist for the current project.
# 	- If any folders are missing (including child src and inc folders) they would be created.
#	- If any modules are missing in the project.yaml but a directory is found, they are ignored.
# 	** Module directories in this case must be removed using the $(bulgogi module remove <name>) command.
# 2. Provide a .sync() method for the project 
# 	- This would read the project.yaml file and enforce the project directory structure onto the fs.
# 	x The problem with this is that this would necessarily include removing directories which are not 
#		found in the project.yaml 
#	x It is also unecessarily complex at this stage, but may be needed or wanted down the road.

################# Universalizing directories
# Something to think about for the future: everything works path-wise as long as the project.yaml 
# file is in the PWD of the current shell.
#
# However, if in any instance that a project which was initialized in a parent or child directory 
# of the PWD, locating module folders etc. would be impossible to do correctly without losing things 
# and create redundant copies of the same folders along differing hierarchical levels.
#
# For now it's fine to assume that project.yaml location = PWD. But at one point it would be very nice 
# to be able to be in a module directory or deeper in a subdirectory and still be able to call bulgogi 
# functions and have the thing build etc.
#
# It could be achieved if modules had module.yaml files which could be read for reference info (i.e.: where is the 
# project.yaml? what is this module called? etc.) but we're not there yet.

################# A note on spawn and module add behavior
# The current implementation of 'spawn' -- both in the direct use of the bulgogi spawn command 
# and the indirect need to spawn directories when adding modules -- will 'create' any and all 
# modules found to be without a directory even if *adjacent* to the one being created.
#
# In other words, in the instance where module1 and module2 are defined in the project.yaml and one
# entry is removed, a calling to $(bulgogi module add --create module3) will re-spawn module1 as a 
# blank module.
#
# This behavior is not bad, but questionable: why is module1 missing from the project directory? Was this 
# done on purpose? If so, should the default behavior be to re-create the directory in its empty format?
