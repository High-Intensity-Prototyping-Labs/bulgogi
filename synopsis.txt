# Bulgogi Synopsis
# InDev v0.5.1

# NOTE: Largely inspired by git cli.

# Initializes a new bulgogi project in the current dir
bulgogi init

# Empty projects do not contain anything.

# Alias: Bulgogi CLI tool should be aliased to `bul`.

# Adds a module to the bulgogi project
bulgogi module add module1
bulgogi module add --create telemetry

# Adds a module to a specific target 
# (Adds to the default target if not specified)
# (--create flag specifies that the module folder does not yet exist)
bulgogi module add module1 target1
bulgogi module add --create telemetry utils 

# Adds a new target to the project 
# (--library or --binary) specifies which type explicitly (default binary)
bulgogi target add target1 
bulgogi target add --library utils

# Build project
bulgogi build

# Clean project
# Specifically, removes all untracked project files and directories
bulgogi clean

# Removes module from the project
bulgogi rm module/

# Alternative ideas
# bulgogi module rm module1/
# bulgogi module rm --cached module1/
# (simply removes module from tracking but preserves files)

# Display project structure (tree)
bulgogi tree

# Sample output from bulgogi tree
# target1
#  |_ module1 (C++)
#  |_ module2 (C++)
# 
# target2
#  |_ module3 (Py3)
#  |_ target1 (C++)

# Smart functions (educated guesses)
bulgogi add module2   # Detects module, aliases to module add module2 
bulgogi rm telemetry  # Detects module, aliases to module rm module2 
bulgogi add source3.c # Source detected, creates a module for it and moves it 
bulgogi add source5.c module2 # Adds source to specific module 

###########################################################

# File: project.yaml
# Contains the project structure persistent state.
# Bulgogi primarily works by reading and updating this file.

# project.yaml
default:		# Target 
	module1*	# Dependency 1 (contains main)
	module2		# Dependency 2

target1:		# Target
	module3		# Dependency 1
	module4		# Dependency 2

target2:		# Target
	module3		# Dependency 1
	module5*	# Dependency 2 (contains main)
	target1		# Dependency 3 (implies target1 is a lib/shared lib)

**NOTE: A dependency can be a target OR a module. Targets used as dependencies imply lib.

# project directory
project/
	|- module1/
		|- inc/
			|- header1.h
			|- header2.h 
		|- src/
			|- source1.c 
			|- source2.c 
			|- inc/
				|- private1.h 
				|- private2.h 

/* Repeat the same for module 2 */

# CMake Targets
default:	# default.out			# What the user wants
	module1*	# default.out		# What bulgogi tells CMake
	module2		# libmodule2.a		# || || || || || || || ||

target1:	# libtarget1.a
	module3		# libmodule3.a
	module4		# libmodule4.a

target2:	# target2.out
	module3		# libmodule3.a
	module5*	# target2.out
	target1		# libtarget1.a (implies library)

# Exceptions
default:	# default.out
	target1*	# Shared object?
	module2

target1:	# target1.out
	module1*	# target1.out

# Bottom line: targets marked as executable dependencies are treated as
# normal target-libraries

# HashMaps
targets:
        default: 
                kind: Executable 
        target1:
                kind: Library 
        target2:
                kind: Executable 

modules:
        module1:
                kind: Executable
        module2:
                kind: Normal
        module3:
                kind: Normal 
        module4:
                kind: Normal
        module5:
                kind: Executable

deps:
        default:
                Module(module1)
                Module(module2)
        target1:
                Module(module3)
                Module(module4)
        target2:
                Module(module3)
                Module(module5)
                Target(target1)

/** Long-form droney bits **/

# Gotta give up on proxy libraries 
# --------------------------------
# After many flip flops, I have realized that it will not be practical
# to use proxy submodules for Bulgogi/CMake libraries.
#
# The main reason for this being that, unlike executable proxies (which are
# required), proxy libraries are not indicated in the project config.
#
# Although it would not be impossible to implement a 'dibs' system on such 
# proxy lib submodules, this can allow for situations in which 2 'twin' target
# libraries are defined with the same module-dependencies. The orchestrator would
# need to account for these situations, which would be annoying and require more 
# back and forth with the user.
#
# The simplest solution here is to compile modules as standalone libraries and then 
# add each of the target-libraries to the CMake build as meta-libraries which simply 
# link globs of libmodules together.
#
# Executables then proxy themselves based on the (*) indicator. Library targets are 
# declared in the highest-level CMakelist.txt after all of the submodules are included.

# The HashMap Update: 0.5.0
# -------------------------
# This time we've realized that HashMaps are our friends. 
#
# The Project struct will now be a hasmap which can be crawled like a graph.
#
# Every target has a target ID, which is in fact its name. The key will be a String.
#
# Targets have lists of Dependencies, of which some may be modules (with module IDs) and others 
# may be targets (with Target IDs corresponding to an existing target in the HashMap).
#
# This way, without fighting the underlying data structures, the desired representation and functionality 
# may be implemented. This will also greatly ease conversion from the bulgogi Project to a CMakeProject.
#
# Dependencies must also be defined. The must, at the very least, define a source directory or another 
# target.

# I just remembered: executables are special 
# ------------------------------------------
# The whole need for "proxy" modules for targets stems from the special need for executable targets 
# to have the main() sources added directly to them.
#
# If a mechanism exists for executables to be created this way in the CMake translation, why wouldn't 
# libraries do this as well? Now I remember the line of thinking I was going on and why it's been so 
# damn hard to break from it.
#
# Still, for now, I think it would be best to let executables think they're special (and so treat them
# that way) and then continue with the direct interpretation for the libraries and the rest.
#
# So in other words: executables have proxy modules (which is what the * helps with anyway) and everything
# else is a library.

# New way of thinking: Bulgogi is a CMake orchestrator
# ----------------------------------------------------
# Rather than try and be clever by designating some module directories to be 'proxy' libraries 
# and executables, passing modules directly as libraries to CMake (even in cases when the library
# target and the module are indistinguishable) and leaving it to be CMake's problem (or the user's 
# desire), a level of simplicity and fine-grained control is simultaneously unlocked.
#
# I am seeing this as a bit of an A/B test, especially considering that I have flip-flopped between
# wanting to have proxy target modules and not. 
#
# On the positive end, proxy modules are a more natural/stylistic interpretation of the desired project
# layout. If a human were adapting the bulgogi project.yaml file into a CMake project, it would be 
# surprising to me if they would choose to create a library which only links to another lone library.
#
# On the flipside, if the bulgogi configuration _implies_ that a lone module is part of a lone library,
# why not accept this as the user's wish? This would be a much more direct interpretation of the desired
# project layout. This could be a very easy to produce a library file which I can send to my buddy just 
# on the side. 

# All modules are treated as libraries
# -----------------------------------
# Unless indicated by a * in the project config, all modules are treated like potential libraries.
# 
# This is helpful because it supports the existing CMake architecture that is being inherited and
# allows more than one target to link against the module.
#
# Additionally, when flagged as containing a main() routine with a *, executable targets can ensure
# the presence of a dedicated main() module. For simplicity, they can also be standalone executables
# in smaller/simpler projects

# Bulgogi targets are abstract groupings
# --------------------------------------
# As an orchestrator, bulgogi constructs and concepts are designed to faciliate
# build system management and the user development process.
#
# The high-level distinction between a target and a module is merely an abstraction
# which serves to distinguish products (executables) from intermediaries (libraries).
#
# This is not a conventional or 'good' way of thinking of binaries and libraries. But
# that isn't the point. Within a self-contained project, this is how things conceptually
# flow.

# Targets without an executable component
# ---------------------------------------
# A new thought: targets which do not have an executable component specified (module*)
# will be considered target libraries.
#
# This way, there are 3 kinds of CMake targets that bulgogi can generate:
# - Executable target (links against libraries + has executable component),
# - Library target (composed of modules but no executable component),
# - Library modules (smallest compilation unit recognized by bulgogi).

################## Cyclic Dependencies 
# A cyclic dependency check has been implemented for every conversion
# from a serde_yaml mapping into a Project struct.
#
# This is largely for A. safety (mistakes happen) and B. to prevent panics,
# runoffs and disasters down the road when those cyclic dependencies appear
# elsewhere (like in the CMake files which we are trying to keep the user
# out of in the first place).
#
# It currently works by iterating over each of the project targets and searching
# for target-type dependencies in other targets (or in itself for that matter).
# Further recursing is performed into each of the dependencies associated to the
# target-type dependencies until a match to the 'parent' target is found -- implying
# that by travelling laterally across the dependency tree we found our way back to the
# start.
#
# The user is notified and the program panics if this is encountered. No work should been
# done or attempted if the configuration suggests something impossible (or which could 
# easily be addressed using a common abstraction target which prevents the cycle).

################### Adding Modules
# As per the suggested synopsis, modules are to be added using the 
# $(bulgogi module add <name>) command.
#
# Unique to the init command, a default project and project directory must be spawned.
# Internally this is easy since the project struct just needs to be initialized to its 
# default value. 
#
# Ideas to spawn module directories:
# 1. Provide a .spawn() method for the project 
# 	- This would ensure that all module folders exist for the current project.
# 	- If any folders are missing (including child src and inc folders) they would be created.
#	- If any modules are missing in the project.yaml but a directory is found, they are ignored.
# 	** Module directories in this case must be removed using the $(bulgogi module remove <name>) command.
# 2. Provide a .sync() method for the project 
# 	- This would read the project.yaml file and enforce the project directory structure onto the fs.
# 	x The problem with this is that this would necessarily include removing directories which are not 
#		found in the project.yaml 
#	x It is also unecessarily complex at this stage, but may be needed or wanted down the road.

################# Universalizing directories
# Something to think about for the future: everything works path-wise as long as the project.yaml 
# file is in the PWD of the current shell.
#
# However, if in any instance that a project which was initialized in a parent or child directory 
# of the PWD, locating module folders etc. would be impossible to do correctly without losing things 
# and create redundant copies of the same folders along differing hierarchical levels.
#
# For now it's fine to assume that project.yaml location = PWD. But at one point it would be very nice 
# to be able to be in a module directory or deeper in a subdirectory and still be able to call bulgogi 
# functions and have the thing build etc.
#
# It could be achieved if modules had module.yaml files which could be read for reference info (i.e.: where is the 
# project.yaml? what is this module called? etc.) but we're not there yet.

################# A note on spawn and module add behavior
# The current implementation of 'spawn' -- both in the direct use of the bulgogi spawn command 
# and the indirect need to spawn directories when adding modules -- will 'create' any and all 
# modules found to be without a directory even if *adjacent* to the one being created.
#
# In other words, in the instance where module1 and module2 are defined in the project.yaml and one
# entry is removed, a calling to $(bulgogi module add --create module3) will re-spawn module1 as a 
# blank module.
#
# This behavior is not bad, but questionable: why is module1 missing from the project directory? Was this 
# done on purpose? If so, should the default behavior be to re-create the directory in its empty format?
