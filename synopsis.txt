# Bulgogi Synopsis
# InDev v1.0.0

# NOTE: Largely inspired by git cli.

# Initializes a new bulgogi project
bulgogi init .

# Adds a module to the bulgogi project
bulgogi add module/

# Alternative module ideas
# bulgogi module add module1/
# bulgogi module add --create module1/
# (solves 'no existing module module1')

# Build project
bulgogi build

# Clean project
bulgogi clean

# Removes module from the project
bulgogi rm module/

# Alternative ideas
# bulgogi module rm module1/
# bulgogi module rm --cached module1/
# (simply removes module from tracking but preserves files)

# Display project structure (tree)
bulgogi tree

# Sample output from bulgogi tree
# target1
#  |_ module1 (C++)
#  |_ module2 (C++)
# 
# target2
#  |_ module3 (Py3)
#  |_ target1 (C++)

###########################################################

# File: project.yaml
# Contains the project structure persistent state.
# Bulgogi primarily works by reading and updating this file.

# project.yaml
default:		# Target 
	module1		# Dependency 1
	module2		# Dependency 2

target1:		# Target
	module3		# Dependency 1
	module4		# Dependency 2

target2:		# Target
	module3		# Dependency 1
	target1		# Dependency 2 (implies target1 is a lib)

**NOTE: A dependency can be a target OR a module. Targets used as dependencies imply lib.

# project directory
project/
	|- module1/
		|- inc/
			|- header1.h
			|- header2.h 
		|- src/
			|- source1.c 
			|- source2.c 
			|- inc/
				|- private1.h 
				|- private2.h 

/* Repeat the same for module 2 */

Results from serde_yaml for the current structure:

targets:
- name: default
  deps:
  - module:
      path: module1
    target: null
  - module:
      path: module2
    target: null

vs the expected output:

default:
	module1
	module2

################ A note on serde yaml:
# Yaml supports mapping types, which are key-value pairs primitives in rust and the markup.
# https://docs.rs/serde_yaml/latest/serde_yaml/struct.Mapping.html
# Basically, do some background reading on how the map works, because all the rust structs 
# are really just proxy attempts at making this work.
#
# The annoyance of the struct field names being fixed vs my desire for customizable keys comes
# from a misuse or misundertanding of the parent data structure. A map is truly the custom key 
# custom value structure that I am looking for.
