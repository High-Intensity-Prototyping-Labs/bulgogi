# Bulgogi Synopsis
# InDev v1.0.0

# NOTE: Largely inspired by git cli.

# Initializes a new bulgogi project
bulgogi init .

# Adds a module to the bulgogi project
bulgogi module add module1
bulgogi module add --create telemetry

# Adds a module to a specific target 
# (Adds to the default target if not specified)
# (--create flag specifies that the module folder does not yet exist)
bulgogi module add module1 target1
bulgogi module add --create telemetry utils 

# Adds a new target to the project 
# (--library or --binary) specifies which type explicitly (default binary)
bulgogi target add target1 
bulgogi target add --library utils

# Build project
bulgogi build

# Clean project
# Specifically, removes all untracked project files and directories
bulgogi clean

# Removes module from the project
bulgogi rm module/

# Alternative ideas
# bulgogi module rm module1/
# bulgogi module rm --cached module1/
# (simply removes module from tracking but preserves files)

# Display project structure (tree)
bulgogi tree

# Sample output from bulgogi tree
# target1
#  |_ module1 (C++)
#  |_ module2 (C++)
# 
# target2
#  |_ module3 (Py3)
#  |_ target1 (C++)

# Smart functions (educated guesses)
bulgogi add module2   # Detects module, aliases to module add module2 
bulgogi rm telemetry  # Detects module, aliases to module rm module2 
bulgogi add source3.c # Source detected, creates a module for it and moves it 
bulgogi add source5.c module2 # Adds source to specific module 

###########################################################

# File: project.yaml
# Contains the project structure persistent state.
# Bulgogi primarily works by reading and updating this file.

# project.yaml
default:		# Target 
	module1		# Dependency 1
	module2		# Dependency 2

target1:		# Target
	module3		# Dependency 1
	module4		# Dependency 2

target2:		# Target
	module3		# Dependency 1
	target1		# Dependency 2 (implies target1 is a lib)

**NOTE: A dependency can be a target OR a module. Targets used as dependencies imply lib.

# project directory
project/
	|- module1/
		|- inc/
			|- header1.h
			|- header2.h 
		|- src/
			|- source1.c 
			|- source2.c 
			|- inc/
				|- private1.h 
				|- private2.h 

/* Repeat the same for module 2 */

################## Cyclic Dependencies 
# A cyclic dependency check has been implemented for every conversion
# from a serde_yaml mapping into a Project struct.
#
# This is largely for A. safety (mistakes happen) and B. to prevent panics,
# runoffs and disasters down the road when those cyclic dependencies appear
# elsewhere (like in the CMake files which we are trying to keep the user
# out of in the first place).
#
# It currently works by iterating over each of the project targets and searching
# for target-type dependencies in other targets (or in itself for that matter).
# Further recursing is performed into each of the dependencies associated to the
# target-type dependencies until a match to the 'parent' target is found -- implying
# that by travelling laterally across the dependency tree we found our way back to the
# start.
#
# The user is notified and the program panics if this is encountered. No work should been
# done or attempted if the configuration suggests something impossible (or which could 
# easily be addressed using a common abstraction target which prevents the cycle).

################### Adding Modules
# As per the suggested synopsis, modules are to be added using the 
# $(bulgogi module add <name>) command.
#
# Unique to the init command, a default project and project directory must be spawned.
# Internally this is easy since the project struct just needs to be initialized to its 
# default value. 
#
# Ideas to spawn module directories:
# 1. Provide a .spawn() method for the project 
# 	- This would ensure that all module folders exist for the current project.
# 	- If any folders are missing (including child src and inc folders) they would be created.
#	- If any modules are missing in the project.yaml but a directory is found, they are ignored.
# 	** Module directories in this case must be removed using the $(bulgogi module remove <name>) command.
# 2. Provide a .sync() method for the project 
# 	- This would read the project.yaml file and enforce the project directory structure onto the fs.
# 	x The problem with this is that this would necessarily include removing directories which are not 
#		found in the project.yaml 
#	x It is also unecessarily complex at this stage, but may be needed or wanted down the road.

################# Universalizing directories
# Something to think about for the future: everything works path-wise as long as the project.yaml 
# file is in the PWD of the current shell.
#
# However, if in any instance that a project which was initialized in a parent or child directory 
# of the PWD, locating module folders etc. would be impossible to do correctly without losing things 
# and create redundant copies of the same folders along differing hierarchical levels.
#
# For now it's fine to assume that project.yaml location = PWD. But at one point it would be very nice 
# to be able to be in a module directory or deeper in a subdirectory and still be able to call bulgogi 
# functions and have the thing build etc.
#
# It could be achieved if modules had module.yaml files which could be read for reference info (i.e.: where is the 
# project.yaml? what is this module called? etc.) but we're not there yet.

################# A note on spawn and module add behavior
# The current implementation of 'spawn' -- both in the direct use of the bulgogi spawn command 
# and the indirect need to spawn directories when adding modules -- will 'create' any and all 
# modules found to be without a directory even if *adjacent* to the one being created.
#
# In other words, in the instance where module1 and module2 are defined in the project.yaml and one
# entry is removed, a calling to $(bulgogi module add --create module3) will re-spawn module1 as a 
# blank module.
#
# This behavior is not bad, but questionable: why is module1 missing from the project directory? Was this 
# done on purpose? If so, should the default behavior be to re-create the directory in its empty format?
