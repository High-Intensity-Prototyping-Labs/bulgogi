Inferencing Engine:
        -> Target Hash ( name, type ) = Unique ID
                -> No more using strings as the identifier.
                -> Instead a target's name and its type will generate a unique ID.
                -> Everything will be worked in terms of those IDs.
        -> Target Usage ( Project, Hash ) = Atom, Lib, Exe, Ambiguous.
                -> Result of analyzing a project to obtain a target's usage.
                -> Powered by inference, the worst case is ambiguity.
                -> 

Other Notes:
        -> Everything is a target.
        -> There is no longer a distinction between Module/Library/Executable.

Target Configuration:
        -> This is what I am aiming for for bulgogi's self-build:

        bulgogi:
        - cmake
        - client*
        - project

        cmake:
        - project

        -> Notice that the name cmake is re-used. This should be an integral feature.


Engine Operation:
        -> For each sequence event,
                -> Add the previous scalar event as a potential target.
                -> Add each scalar event in the sequence as potential targets.
                -> Stop. 
        -> For each potential target 
                -> First assume they are executable.
                -> If the same target re-appears, it becomes a library.
                -> Stop.
        -> Review the list of targets 
                -> All deps of a library becomes libs themselves.
                -> If a target has more than 1 executable dependency, flag ambiguity.
                -> Otherwise, generate build files.
                -> Done.

Ambiguity Detection:
        -> Ambiguity occurs when more than 1 executable dependencies are 
           attached to one target.
